import { baseFetchConfig, debug as d } from "../platform.deno.ts";
import { toGrammyError, toHttpError } from "./error.ts";
import { createFormDataPayload, createJsonPayload, requiresFormDataUpload } from "./payload.ts";
const debug = d("grammy:core");
// Transformer base functions
function concatTransformer(prev, trans) {
  return (method, payload, signal)=>trans(prev, method, payload, signal);
}
class ApiClient {
  token;
  webhookReplyEnvelope;
  options;
  hasUsedWebhookReply;
  installedTransformers;
  constructor(token, options = {}, webhookReplyEnvelope = {}){
    this.token = token;
    this.webhookReplyEnvelope = webhookReplyEnvelope;
    this.hasUsedWebhookReply = false;
    this.installedTransformers = [];
    this.call = async (method, p, signal)=>{
      const payload = p ?? {};
      debug(`Calling ${method}`);
      if (signal !== undefined) validateSignal(method, payload, signal);
      // General config
      const opts = this.options;
      const formDataRequired = requiresFormDataUpload(payload);
      // Short-circuit on webhook reply
      if (this.webhookReplyEnvelope.send !== undefined && !this.hasUsedWebhookReply && !formDataRequired && opts.canUseWebhookReply(method)) {
        this.hasUsedWebhookReply = true;
        const config = createJsonPayload({
          ...payload,
          method
        });
        await this.webhookReplyEnvelope.send(config.body);
        return {
          ok: true,
          result: true
        };
      }
      // Handle timeouts and errors in the underlying form-data stream
      const controller = createAbortControllerFromSignal(signal);
      const timeout = createTimeout(controller, opts.timeoutSeconds, method);
      const streamErr = createStreamError(controller);
      // Build request URL and config
      const url = opts.buildUrl(opts.apiRoot, this.token, method, opts.environment);
      const config = formDataRequired ? createFormDataPayload(payload, (err)=>streamErr.catch(err)) : createJsonPayload(payload);
      const sig = controller.signal;
      const options = {
        ...opts.baseFetchConfig,
        signal: sig,
        ...config
      };
      // Perform fetch call, and handle networking errors
      const successPromise = fetch(url instanceof URL ? url.href : url, options).catch(toHttpError(method, opts.sensitiveLogs));
      // Those are the three possible outcomes of the fetch call:
      const operations = [
        successPromise,
        streamErr.promise,
        timeout.promise
      ];
      // Wait for result
      try {
        const res = await Promise.race(operations);
        return await res.json();
      } finally{
        if (timeout.handle !== undefined) clearTimeout(timeout.handle);
      }
    };
    const apiRoot = options.apiRoot ?? "https://api.telegram.org";
    const environment = options.environment ?? "prod";
    this.options = {
      apiRoot,
      environment,
      buildUrl: options.buildUrl ?? defaultBuildUrl,
      timeoutSeconds: options.timeoutSeconds ?? 500,
      baseFetchConfig: {
        ...baseFetchConfig(apiRoot),
        ...options.baseFetchConfig
      },
      canUseWebhookReply: options.canUseWebhookReply ?? (()=>false),
      sensitiveLogs: options.sensitiveLogs ?? false
    };
    if (this.options.apiRoot.endsWith("/")) {
      throw new Error(`Remove the trailing '/' from the 'apiRoot' option (use '${this.options.apiRoot.substring(0, this.options.apiRoot.length - 1)}' instead of '${this.options.apiRoot}')`);
    }
  }
  call;
  use(...transformers) {
    this.call = transformers.reduce(concatTransformer, this.call);
    this.installedTransformers.push(...transformers);
    return this;
  }
  async callApi(method, payload, signal) {
    const data = await this.call(method, payload, signal);
    if (data.ok) return data.result;
    else throw toGrammyError(data, method, payload);
  }
}
/**
 * Creates a new transformable API, i.e. an object that lets you perform raw API
 * calls to the Telegram Bot API server but pass the calls through a stack of
 * transformers before. This will create a new API client instance under the
 * hood that will be used to connect to the Telegram servers. You therefore need
 * to pass the bot token. In addition, you may pass API client options as well
 * as a webhook reply envelope that allows the client to perform up to one HTTP
 * request in response to a webhook call if this is desired.
 *
 * @param token The bot's token
 * @param options A number of options to pass to the created API client
 * @param webhookReplyEnvelope The webhook reply envelope that will be used
 */ export function createRawApi(token, options, webhookReplyEnvelope) {
  const client = new ApiClient(token, options, webhookReplyEnvelope);
  const proxyHandler = {
    get (_, m) {
      return m === "toJSON" ? "__internal" : client.callApi.bind(client, m);
    },
    ...proxyMethods
  };
  const raw = new Proxy({}, proxyHandler);
  const installedTransformers = client.installedTransformers;
  const api = {
    raw,
    installedTransformers,
    use: (...t)=>{
      client.use(...t);
      return api;
    }
  };
  return api;
}
const defaultBuildUrl = (root, token, method, env)=>{
  const prefix = env === "test" ? "test/" : "";
  return `${root}/bot${token}/${prefix}${method}`;
};
const proxyMethods = {
  set () {
    return false;
  },
  defineProperty () {
    return false;
  },
  deleteProperty () {
    return false;
  },
  ownKeys () {
    return [];
  }
};
/** Creates a timeout error which aborts a given controller */ function createTimeout(controller, seconds, method) {
  let handle = undefined;
  const promise = new Promise((_, reject)=>{
    handle = setTimeout(()=>{
      const msg = `Request to '${method}' timed out after ${seconds} seconds`;
      reject(new Error(msg));
      controller.abort();
    }, 1000 * seconds);
  });
  return {
    promise,
    handle
  };
}
/** Creates a stream error which abort a given controller */ function createStreamError(abortController) {
  let onError = (err)=>{
    // Re-throw by default, but will be overwritten immediately
    throw err;
  };
  const promise = new Promise((_, reject)=>{
    onError = (err)=>{
      reject(err);
      abortController.abort();
    };
  });
  return {
    promise,
    catch: onError
  };
}
function createAbortControllerFromSignal(signal) {
  const abortController = new AbortController();
  if (signal === undefined) return abortController;
  const sig = signal;
  function abort() {
    abortController.abort();
    sig.removeEventListener("abort", abort);
  }
  if (sig.aborted) abort();
  else sig.addEventListener("abort", abort);
  return {
    abort,
    signal: abortController.signal
  };
}
function validateSignal(method, payload, signal) {
  // We use a very simple heuristic to check for AbortSignal instances
  // in order to avoid doing a runtime-specific version of `instanceof`.
  if (typeof signal?.addEventListener === "function") {
    return;
  }
  let payload0 = JSON.stringify(payload);
  if (payload0.length > 20) {
    payload0 = payload0.substring(0, 16) + " ...";
  }
  let payload1 = JSON.stringify(signal);
  if (payload1.length > 20) {
    payload1 = payload1.substring(0, 16) + " ...";
  }
  throw new Error(`Incorrect abort signal instance found! \
You passed two payloads to '${method}' but you should merge \
the second one containing '${payload1}' into the first one \
containing '${payload0}'! If you are using context shortcuts, \
you may want to use a method on 'ctx.api' instead.

If you want to prevent such mistakes in the future, \
consider using TypeScript. https://www.typescriptlang.org/`);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvZ3JhbW15QHYxLjMwLjAvY29yZS9jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmFzZUZldGNoQ29uZmlnLCBkZWJ1ZyBhcyBkIH0gZnJvbSBcIi4uL3BsYXRmb3JtLmRlbm8udHNcIjtcbmltcG9ydCB7XG4gICAgdHlwZSBBcGlNZXRob2RzIGFzIFRlbGVncmFtLFxuICAgIHR5cGUgQXBpUmVzcG9uc2UsXG4gICAgdHlwZSBPcHRzLFxufSBmcm9tIFwiLi4vdHlwZXMudHNcIjtcbmltcG9ydCB7IHRvR3JhbW15RXJyb3IsIHRvSHR0cEVycm9yIH0gZnJvbSBcIi4vZXJyb3IudHNcIjtcbmltcG9ydCB7XG4gICAgY3JlYXRlRm9ybURhdGFQYXlsb2FkLFxuICAgIGNyZWF0ZUpzb25QYXlsb2FkLFxuICAgIHJlcXVpcmVzRm9ybURhdGFVcGxvYWQsXG59IGZyb20gXCIuL3BheWxvYWQudHNcIjtcbmNvbnN0IGRlYnVnID0gZChcImdyYW1teTpjb3JlXCIpO1xuXG5leHBvcnQgdHlwZSBNZXRob2RzPFIgZXh0ZW5kcyBSYXdBcGk+ID0gc3RyaW5nICYga2V5b2YgUjtcblxuLy8gQXZhaWxhYmxlIHVuZGVyIGBib3QuYXBpLnJhd2Bcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcmF3IFRlbGVncmFtIEJvdCBBUEkgd2l0aCBhbGwgbWV0aG9kcyBzcGVjaWZpZWQgMToxIGFzXG4gKiBkb2N1bWVudGVkIG9uIHRoZSB3ZWJzaXRlIChodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpKS5cbiAqXG4gKiBFdmVyeSBtZXRob2QgdGFrZXMgYW4gb3B0aW9uYWwgYEFib3J0U2lnbmFsYCBvYmplY3QgdGhhdCBhbGxvd3MgdG8gY2FuY2VsIHRoZVxuICogQVBJIGNhbGwgaWYgZGVzaXJlZC5cbiAqL1xuZXhwb3J0IHR5cGUgUmF3QXBpID0ge1xuICAgIFtNIGluIGtleW9mIFRlbGVncmFtXTogUGFyYW1ldGVyczxUZWxlZ3JhbVtNXT5bMF0gZXh0ZW5kcyB1bmRlZmluZWRcbiAgICAgICAgPyAoc2lnbmFsPzogQWJvcnRTaWduYWwpID0+IFByb21pc2U8UmV0dXJuVHlwZTxUZWxlZ3JhbVtNXT4+XG4gICAgICAgIDogKFxuICAgICAgICAgICAgYXJnczogT3B0czxNPixcbiAgICAgICAgICAgIHNpZ25hbD86IEFib3J0U2lnbmFsLFxuICAgICAgICApID0+IFByb21pc2U8UmV0dXJuVHlwZTxUZWxlZ3JhbVtNXT4+O1xufTtcblxuZXhwb3J0IHR5cGUgUGF5bG9hZDxNIGV4dGVuZHMgTWV0aG9kczxSPiwgUiBleHRlbmRzIFJhd0FwaT4gPSBNIGV4dGVuZHMgdW5rbm93blxuICAgID8gUltNXSBleHRlbmRzIChzaWduYWw/OiBBYm9ydFNpZ25hbCkgPT4gdW5rbm93biAvLyBkZW5vLWxpbnQtaWdub3JlIGJhbi10eXBlc1xuICAgICAgICA/IHt9IC8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG4gICAgOiBSW01dIGV4dGVuZHMgKGFyZ3M6IGFueSwgc2lnbmFsPzogQWJvcnRTaWduYWwpID0+IHVua25vd25cbiAgICAgICAgPyBQYXJhbWV0ZXJzPFJbTV0+WzBdXG4gICAgOiBuZXZlclxuICAgIDogbmV2ZXI7XG5cbi8qKlxuICogU21hbGwgdXRpbGl0eSBpbnRlcmZhY2UgdGhhdCBhYnN0cmFjdHMgZnJvbSB3ZWJob29rIHJlcGx5IGNhbGxzIG9mIGRpZmZlcmVudFxuICogd2ViIGZyYW1ld29ya3MuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV2ViaG9va1JlcGx5RW52ZWxvcGUge1xuICAgIHNlbmQ/OiAocGF5bG9hZDogc3RyaW5nKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbn1cblxuLyoqXG4gKiBUeXBlIG9mIGEgZnVuY3Rpb24gdGhhdCBjYW4gcGVyZm9ybSBhbiBBUEkgY2FsbC4gVXNlZCBmb3IgVHJhbnNmb3JtZXJzLlxuICovXG5leHBvcnQgdHlwZSBBcGlDYWxsRm48UiBleHRlbmRzIFJhd0FwaSA9IFJhd0FwaT4gPSA8TSBleHRlbmRzIE1ldGhvZHM8Uj4+KFxuICAgIG1ldGhvZDogTSxcbiAgICBwYXlsb2FkOiBQYXlsb2FkPE0sIFI+LFxuICAgIHNpZ25hbD86IEFib3J0U2lnbmFsLFxuKSA9PiBQcm9taXNlPEFwaVJlc3BvbnNlPEFwaUNhbGxSZXN1bHQ8TSwgUj4+PjtcblxudHlwZSBBcGlDYWxsUmVzdWx0PE0gZXh0ZW5kcyBNZXRob2RzPFI+LCBSIGV4dGVuZHMgUmF3QXBpPiA9IFJbTV0gZXh0ZW5kc1xuICAgICguLi5hcmdzOiB1bmtub3duW10pID0+IHVua25vd24gPyBBd2FpdGVkPFJldHVyblR5cGU8UltNXT4+IDogbmV2ZXI7XG5cbi8qKlxuICogQVBJIGNhbGwgdHJhbnNmb3JtZXJzIGFyZSBmdW5jdGlvbnMgdGhhdCBjYW4gYWNjZXNzIGFuZCBtb2RpZnkgdGhlIG1ldGhvZCBhbmRcbiAqIHBheWxvYWQgb2YgYW4gQVBJIGNhbGwgb24gdGhlIGZseS4gVGhpcyBjYW4gYmUgdXNlZnVsIGlmIHlvdSB3YW50IHRvXG4gKiBpbXBsZW1lbnQgcmF0ZSBsaW1pdGluZyBvciBvdGhlciB0aGluZ3MgYWdhaW5zdCB0aGUgVGVsZWdyYW0gQm90IEFQSS5cbiAqXG4gKiBDb25mZXIgdGhlIGdyYW1tWVxuICogW2RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ3JhbW15LmRldi9hZHZhbmNlZC90cmFuc2Zvcm1lcnMpIHRvIHJlYWQgbW9yZVxuICogYWJvdXQgaG93IHRvIHVzZSB0cmFuc2Zvcm1lcnMuXG4gKi9cbmV4cG9ydCB0eXBlIFRyYW5zZm9ybWVyPFIgZXh0ZW5kcyBSYXdBcGkgPSBSYXdBcGk+ID0gPE0gZXh0ZW5kcyBNZXRob2RzPFI+PihcbiAgICBwcmV2OiBBcGlDYWxsRm48Uj4sXG4gICAgbWV0aG9kOiBNLFxuICAgIHBheWxvYWQ6IFBheWxvYWQ8TSwgUj4sXG4gICAgc2lnbmFsPzogQWJvcnRTaWduYWwsXG4pID0+IFByb21pc2U8QXBpUmVzcG9uc2U8QXBpQ2FsbFJlc3VsdDxNLCBSPj4+O1xuZXhwb3J0IHR5cGUgVHJhbnNmb3JtZXJDb25zdW1lcjxSIGV4dGVuZHMgUmF3QXBpID0gUmF3QXBpPiA9IFRyYW5zZm9ybWFibGVBcGk8XG4gICAgUlxuPltcInVzZVwiXTtcbi8qKlxuICogQSB0cmFuc2Zvcm1hYmxlIEFQSSBlbmhhbmNlcyB0aGUgYFJhd0FwaWAgdHlwZSBieSB0cmFuc2Zvcm1lcnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmb3JtYWJsZUFwaTxSIGV4dGVuZHMgUmF3QXBpID0gUmF3QXBpPiB7XG4gICAgLyoqXG4gICAgICogQWNjZXNzIHRvIHRoZSByYXcgQVBJIHRoYXQgdGhlIHRyYW5zZm9ybWVycyB3aWxsIGJlIGluc3RhbGxlZCBvbi5cbiAgICAgKi9cbiAgICByYXc6IFI7XG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgYW55IG51bWJlciBvZiB0cmFuc2Zvcm1lcnMgb24gdGhlIEFQSS5cbiAgICAgKi9cbiAgICB1c2U6ICguLi50cmFuc2Zvcm1lcnM6IFRyYW5zZm9ybWVyPFI+W10pID0+IHRoaXM7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlYWRvbmx5IGxpc3Qgb3IgdGhlIGN1cnJlbnRseSBpbnN0YWxsZWQgdHJhbnNmb3JtZXJzLiBUaGUgbGlzdFxuICAgICAqIGlzIHNvcnRlZCBieSB0aW1lIG9mIGluc3RhbGxhdGlvbiB3aGVyZSBpbmRleCAwIHJlcHJlc2VudHMgdGhlXG4gICAgICogdHJhbnNmb3JtZXIgdGhhdCB3YXMgaW5zdGFsbGVkIGZpcnN0LlxuICAgICAqL1xuICAgIGluc3RhbGxlZFRyYW5zZm9ybWVyczogVHJhbnNmb3JtZXI8Uj5bXTtcbn1cblxuLy8gVHJhbnNmb3JtZXIgYmFzZSBmdW5jdGlvbnNcbmZ1bmN0aW9uIGNvbmNhdFRyYW5zZm9ybWVyPFIgZXh0ZW5kcyBSYXdBcGk+KFxuICAgIHByZXY6IEFwaUNhbGxGbjxSPixcbiAgICB0cmFuczogVHJhbnNmb3JtZXI8Uj4sXG4pOiBBcGlDYWxsRm48Uj4ge1xuICAgIHJldHVybiAobWV0aG9kLCBwYXlsb2FkLCBzaWduYWwpID0+IHRyYW5zKHByZXYsIG1ldGhvZCwgcGF5bG9hZCwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSSBjbGllbnQgdGhhdCBldmVudHVhbGx5IGNvbm5lY3RzIHRvIHRoZSBUZWxlZ3JhbVxuICogQm90IEFQSSBzZXJ2ZXIgYW5kIG1ha2VzIHRoZSBIVFRQIHJlcXVlc3RzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFwaUNsaWVudE9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIFJvb3QgVVJMIG9mIHRoZSBUZWxlZ3JhbSBCb3QgQVBJIHNlcnZlci4gRGVmYXVsdDpcbiAgICAgKiBodHRwczovL2FwaS50ZWxlZ3JhbS5vcmdcbiAgICAgKi9cbiAgICBhcGlSb290Pzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHRvIHVzZSB0aGUgW3Rlc3RcbiAgICAgKiBlbnZpcm9ubWVudF0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL3dlYmFwcHMjdXNpbmctYm90cy1pbi10aGUtdGVzdC1lbnZpcm9ubWVudCkuXG4gICAgICogQ2FuIGJlIGVpdGhlciBgXCJwcm9kXCJgIChkZWZhdWx0KSBvciBgXCJ0ZXN0XCJgLlxuICAgICAqXG4gICAgICogVGhlIHRlc3RpbmcgaW5mcmFzdHJ1Y3R1cmUgaXMgc2VwYXJhdGUgZnJvbSB0aGUgcmVndWxhciBwcm9kdWN0aW9uXG4gICAgICogaW5mcmFzdHJ1Y3R1cmUuIE5vIGNoYXRzLCBhY2NvdW50cywgb3Igb3RoZXIgZGF0YSBpcyBzaGFyZWQgYmV0d2VlbiB0aGVtLlxuICAgICAqIElmIHlvdSBzZXQgdGhpcyBvcHRpb24gdG8gYFwidGVzdFwiYCwgeW91IHdpbGwgbmVlZCB0byBtYWtlIHlvdXIgVGVsZWdyYW1cbiAgICAgKiBjbGllbnQgY29ubmVjdCB0byB0aGUgdGVzdGluZyBkYXRhIGNlbnRlcnMgb2YgVGVsZWdyYW0sIHJlZ2lzdGVyIHlvdXJcbiAgICAgKiBwaG9uZSBudW1iZXIgYWdhaW4sIG9wZW4gYSBuZXcgY2hhdCB3aXRoIEBCb3RGYXRoZXIsIGFuZCBjcmVhdGUgYVxuICAgICAqIHNlcGFyYXRlIGJvdC5cbiAgICAgKi9cbiAgICBlbnZpcm9ubWVudD86IFwicHJvZFwiIHwgXCJ0ZXN0XCI7XG4gICAgLyoqXG4gICAgICogVVJMIGJ1aWxkZXIgZnVuY3Rpb24gZm9yIEFQSSBjYWxscy4gQ2FuIGJlIHVzZWQgdG8gbW9kaWZ5IHdoaWNoIEFQSVxuICAgICAqIHNlcnZlciBzaG91bGQgYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvb3QgVGhlIFVSTCB0aGF0IHdhcyBwYXNzZWQgaW4gYGFwaVJvb3RgLCBvciBpdHMgZGVmYXVsdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB0b2tlbiBUaGUgYm90J3MgdG9rZW4gdGhhdCB3YXMgcGFzc2VkIHdoZW4gY3JlYXRpbmcgdGhlIGJvdFxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIEFQSSBtZXRob2QgdG8gYmUgY2FsbGVkLCBlLmcuIGBnZXRNZWBcbiAgICAgKiBAcGFyYW0gZW52IFRoZSB2YWx1ZSB0aGF0IHdhcyBwYXNzZWQgaW4gYGVudmlyb25tZW50YCwgb3IgaXRzIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBUaGUgVVJMIHRoYXQgd2lsbCBiZSBmZXRjaGVkIGR1cmluZyB0aGUgQVBJIGNhbGxcbiAgICAgKi9cbiAgICBidWlsZFVybD86IChcbiAgICAgICAgcm9vdDogc3RyaW5nLFxuICAgICAgICB0b2tlbjogc3RyaW5nLFxuICAgICAgICBtZXRob2Q6IHN0cmluZyxcbiAgICAgICAgZW52OiBcInByb2RcIiB8IFwidGVzdFwiLFxuICAgICkgPT4gc3RyaW5nIHwgVVJMO1xuICAgIC8qKlxuICAgICAqIE1heGltdW0gbnVtYmVyIG9mIHNlY29uZHMgdGhhdCBhIHJlcXVlc3QgdG8gdGhlIEJvdCBBUEkgc2VydmVyIG1heSB0YWtlLlxuICAgICAqIElmIGEgcmVxdWVzdCBoYXMgbm90IGNvbXBsZXRlZCBiZWZvcmUgdGhpcyB0aW1lIGhhcyBlbGFwc2VkLCBncmFtbVlcbiAgICAgKiBhYm9ydHMgdGhlIHJlcXVlc3QgYW5kIGVycm9ycy4gV2l0aG91dCBzdWNoIGEgdGltZW91dCwgbmV0d29ya2luZyBpc3N1ZXNcbiAgICAgKiBtYXkgY2F1c2UgeW91ciBib3QgdG8gbGVhdmUgb3BlbiBhIGNvbm5lY3Rpb24gaW5kZWZpbml0ZWx5LCB3aGljaCBtYXlcbiAgICAgKiBlZmZlY3RpdmVseSBtYWtlIHlvdXIgYm90IGZyZWV6ZS5cbiAgICAgKlxuICAgICAqIFlvdSBwcm9iYWJseSBkbyBub3QgaGF2ZSB0byBjYXJlIGFib3V0IHRoaXMgb3B0aW9uLiBJbiByYXJlIGNhc2VzLCB5b3VcbiAgICAgKiBtYXkgd2FudCB0byBhZGp1c3QgaXQgaWYgeW91IGFyZSB0cmFuc2ZlcnJpbmcgbGFyZ2UgZmlsZXMgdmlhIHNsb3dcbiAgICAgKiBjb25uZWN0aW9ucyB0byB5b3VyIG93biBCb3QgQVBJIHNlcnZlci5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IG51bWJlciBvZiBzZWNvbmRzIGlzIGA1MDBgLCB3aGljaCBjb3JyZXNwb25kcyB0byA4IG1pbnV0ZXNcbiAgICAgKiBhbmQgMjAgc2Vjb25kcy4gTm90ZSB0aGF0IHRoaXMgaXMgYWxzbyB0aGUgdmFsdWUgdGhhdCBpcyBoYXJkLWNvZGVkIGluXG4gICAgICogdGhlIG9mZmljaWFsIEJvdCBBUEkgc2VydmVyLCBzbyB5b3UgY2Fubm90IHBlcmZvcm0gYW55IHN1Y2Nlc3NmdWxcbiAgICAgKiByZXF1ZXN0cyB0aGF0IGV4Y2VlZCB0aGlzIHRpbWUgZnJhbWUgKGV2ZW4gaWYgeW91IHdvdWxkIGFsbG93IGl0IGluXG4gICAgICogZ3JhbW1ZKS4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBoaWdoZXIgdGhhbiB0aGUgZGVmYXVsdCBvbmx5IG1ha2VzIHNlbnNlXG4gICAgICogd2l0aCBhIGN1c3RvbSBCb3QgQVBJIHNlcnZlci5cbiAgICAgKi9cbiAgICB0aW1lb3V0U2Vjb25kcz86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYm90IGlzIHJ1bm5pbmcgb24gd2ViaG9va3MsIGFzIHNvb24gYXMgdGhlIGJvdCByZWNlaXZlcyBhbiB1cGRhdGVcbiAgICAgKiBmcm9tIFRlbGVncmFtLCBpdCBpcyBwb3NzaWJsZSB0byBtYWtlIHVwIHRvIG9uZSBBUEkgY2FsbCBpbiB0aGUgcmVzcG9uc2VcbiAgICAgKiB0byB0aGUgd2ViaG9vayByZXF1ZXN0LiBBcyBhIGJlbmVmaXQsIHRoaXMgc2F2ZXMgeW91ciBib3QgZnJvbSBtYWtpbmcgdXBcbiAgICAgKiB0byBvbmUgSFRUUCByZXF1ZXN0IHBlciB1cGRhdGUuIEhvd2V2ZXIsIHRoZXJlIGFyZSBhIG51bWJlciBvZiBkcmF3YmFja3NcbiAgICAgKiB0byB1c2luZyB0aGlzOlxuICAgICAqIDEpIFlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGhhbmRsZSBwb3RlbnRpYWwgZXJyb3JzIG9mIHRoZSByZXNwZWN0aXZlIEFQSVxuICAgICAqICAgIGNhbGwuIFRoaXMgaW5jbHVkZXMgcmF0ZSBsaW1pdGluZyBlcnJvcnMsIHNvIHNlbnQgbWVzc2FnZXMgY2FuIGJlXG4gICAgICogICAgc3dhbGxvd2VkIGJ5IHRoZSBCb3QgQVBJIHNlcnZlciBhbmQgdGhlcmUgaXMgbm8gd2F5IHRvIGRldGVjdCBpZiBhXG4gICAgICogICAgbWVzc2FnZSB3YXMgYWN0dWFsbHkgc2VudCBvciBub3QuXG4gICAgICogMikgTW9yZSBpbXBvcnRhbnRseSwgeW91IGFsc28gd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIHJlc3BvbnNlIG9iamVjdCxcbiAgICAgKiAgICBzbyBlLmcuIGNhbGxpbmcgYHNlbmRNZXNzYWdlYCB3aWxsIG5vdCBnaXZlIHlvdSBhY2Nlc3MgdG8gdGhlIG1lc3NhZ2VcbiAgICAgKiAgICB5b3Ugc2VudC5cbiAgICAgKiAzKSBGdXJ0aGVybW9yZSwgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC4gVGhlXG4gICAgICogICAgYEFib3J0U2lnbmFsYCB3aWxsIGJlIGRpc3JlZ2FyZGVkLlxuICAgICAqIDQpIE5vdGUgYWxzbyB0aGF0IHRoZSB0eXBlcyBpbiBncmFtbVkgZG8gbm90IHJlZmxlY3QgdGhlIGNvbnNlcXVlbmNlcyBvZlxuICAgICAqICAgIGEgcGVyZm9ybWVkIHdlYmhvb2sgY2FsbGJhY2shIEZvciBpbnN0YW5jZSwgdGhleSBpbmRpY2F0ZSB0aGF0IHlvdVxuICAgICAqICAgIGFsd2F5cyByZWNlaXZlIGEgcmVzcG9uc2Ugb2JqZWN0LCBzbyBpdCBpcyB5b3VyIG93biByZXNwb25zaWJpbGl0eSB0b1xuICAgICAqICAgIG1ha2Ugc3VyZSB5b3UncmUgbm90IHNjcmV3aW5nIHVwIHdoaWxlIHVzaW5nIHRoaXMgbWlub3IgcGVyZm9ybWFuY2VcbiAgICAgKiAgICBvcHRpbWl6YXRpb24uXG4gICAgICpcbiAgICAgKiBXaXRoIHRoaXMgd2FybmluZyBvdXQgb2YgdGhlIHdheSwgaGVyZSBpcyB3aGF0IHlvdSBjYW4gZG8gd2l0aCB0aGVcbiAgICAgKiBgY2FuVXNlV2ViaG9va1JlcGx5YCBvcHRpb246IGl0IGNhbiBiZSB1c2VkIHRvIHBhc3MgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogZGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHVzZSB3ZWJob29rIHJlcGx5IGZvciB0aGUgZ2l2ZW4gbWV0aG9kLiBJdCB3aWxsXG4gICAgICogb25seSBiZSBpbnZva2VkIGlmIHRoZSBwYXlsb2FkIGNhbiBiZSBzZW50IGFzIEpTT04uIEl0IHdpbGwgbm90IGJlXG4gICAgICogaW52b2tlZCBhZ2FpbiBmb3IgYSBnaXZlbiB1cGRhdGUgYWZ0ZXIgaXQgcmV0dXJuZWQgYHRydWVgLCBpbmRpY2F0aW5nXG4gICAgICogdGhhdCB0aGUgQVBJIGNhbGwgc2hvdWxkIGJlIHBlcmZvcm1lZCBhcyBhIHdlYmhvb2sgc2VuZC4gSW4gb3RoZXIgd29yZHMsXG4gICAgICogc3Vic2VxdWVudCBBUEkgY2FsbHMgKGR1cmluZyB0aGUgc2FtZSB1cGRhdGUpIHdpbGwgYWx3YXlzIHBlcmZvcm0gdGhlaXJcbiAgICAgKiBvd24gSFRUUCByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIG1ldGhvZCB0byBjYWxsXG4gICAgICovXG4gICAgY2FuVXNlV2ViaG9va1JlcGx5PzogKG1ldGhvZDogc3RyaW5nKSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEJhc2UgY29uZmlndXJhdGlvbiBmb3IgYGZldGNoYCBjYWxscy4gU3BlY2lmeSBhbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICogdG8gdXNlIHdoZW4gZmV0Y2hpbmcgYSBtZXRob2Qgb2YgdGhlIFRlbGVncmFtIEJvdCBBUEkuIERlZmF1bHQ6IGB7XG4gICAgICogY29tcHJlc3M6IHRydWUgfWAgKE5vZGUpLCBge31gIChEZW5vKVxuICAgICAqL1xuICAgIGJhc2VGZXRjaENvbmZpZz86IE9taXQ8XG4gICAgICAgIE5vbk51bGxhYmxlPFBhcmFtZXRlcnM8dHlwZW9mIGZldGNoPlsxXT4sXG4gICAgICAgIFwibWV0aG9kXCIgfCBcImhlYWRlcnNcIiB8IFwiYm9keVwiXG4gICAgPjtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24gaXMgdW5yZWxpYWJsZSBhbmQgc29tZSBBUEkgcmVxdWVzdHMgZmFpbFxuICAgICAqIGJlY2F1c2Ugb2YgdGhhdCwgZ3JhbW1ZIHdpbGwgdGhyb3cgZXJyb3JzIHRoYXQgdGVsbCB5b3UgZXhhY3RseSB3aGljaFxuICAgICAqIHJlcXVlc3RzIGZhaWxlZC4gSG93ZXZlciwgdGhlIGVycm9yIG1lc3NhZ2VzIGRvIG5vdCBkaXNjbG9zZSB0aGUgZmV0Y2hlZFxuICAgICAqIFVSTCBhcyBpdCBjb250YWlucyB5b3VyIGJvdCdzIHRva2VuLiBMb2dnaW5nIGl0IG1heSBsZWFkIHRvIHRva2VuIGxlYWtzLlxuICAgICAqXG4gICAgICogSWYgeW91IGFyZSBzdXJlIHRoYXQgbm8gbG9ncyBhcmUgZXZlciBwb3N0ZWQgaW4gVGVsZWdyYW0gY2hhdHMsIEdpdEh1YlxuICAgICAqIGlzc3Vlcywgb3Igb3RoZXJ3aXNlIHNoYXJlZCwgeW91IGNhbiBzZXQgdGhpcyBvcHRpb24gdG8gYHRydWVgIGluIG9yZGVyXG4gICAgICogdG8gb2J0YWluIG1vcmUgZGV0YWlsZWQgbG9ncyB0aGF0IG1heSBoZWxwIHlvdSBkZWJ1ZyB5b3VyIGJvdC4gVGhlXG4gICAgICogZGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLCBtZWFuaW5nIHRoYXQgdGhlIGJvdCB0b2tlbiBpcyBub3QgbG9nZ2VkLlxuICAgICAqL1xuICAgIHNlbnNpdGl2ZUxvZ3M/OiBib29sZWFuO1xufVxuXG5jbGFzcyBBcGlDbGllbnQ8UiBleHRlbmRzIFJhd0FwaT4ge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogUmVxdWlyZWQ8QXBpQ2xpZW50T3B0aW9ucz47XG5cbiAgICBwcml2YXRlIGhhc1VzZWRXZWJob29rUmVwbHkgPSBmYWxzZTtcblxuICAgIHJlYWRvbmx5IGluc3RhbGxlZFRyYW5zZm9ybWVyczogVHJhbnNmb3JtZXI8Uj5bXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgdG9rZW46IHN0cmluZyxcbiAgICAgICAgb3B0aW9uczogQXBpQ2xpZW50T3B0aW9ucyA9IHt9LFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHdlYmhvb2tSZXBseUVudmVsb3BlOiBXZWJob29rUmVwbHlFbnZlbG9wZSA9IHt9LFxuICAgICkge1xuICAgICAgICBjb25zdCBhcGlSb290ID0gb3B0aW9ucy5hcGlSb290ID8/IFwiaHR0cHM6Ly9hcGkudGVsZWdyYW0ub3JnXCI7XG4gICAgICAgIGNvbnN0IGVudmlyb25tZW50ID0gb3B0aW9ucy5lbnZpcm9ubWVudCA/PyBcInByb2RcIjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgYXBpUm9vdCxcbiAgICAgICAgICAgIGVudmlyb25tZW50LFxuICAgICAgICAgICAgYnVpbGRVcmw6IG9wdGlvbnMuYnVpbGRVcmwgPz8gZGVmYXVsdEJ1aWxkVXJsLFxuICAgICAgICAgICAgdGltZW91dFNlY29uZHM6IG9wdGlvbnMudGltZW91dFNlY29uZHMgPz8gNTAwLFxuICAgICAgICAgICAgYmFzZUZldGNoQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgLi4uYmFzZUZldGNoQ29uZmlnKGFwaVJvb3QpLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuYmFzZUZldGNoQ29uZmlnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhblVzZVdlYmhvb2tSZXBseTogb3B0aW9ucy5jYW5Vc2VXZWJob29rUmVwbHkgPz8gKCgpID0+IGZhbHNlKSxcbiAgICAgICAgICAgIHNlbnNpdGl2ZUxvZ3M6IG9wdGlvbnMuc2Vuc2l0aXZlTG9ncyA/PyBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcGlSb290LmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBSZW1vdmUgdGhlIHRyYWlsaW5nICcvJyBmcm9tIHRoZSAnYXBpUm9vdCcgb3B0aW9uICh1c2UgJyR7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hcGlSb290LnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXBpUm9vdC5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfScgaW5zdGVhZCBvZiAnJHt0aGlzLm9wdGlvbnMuYXBpUm9vdH0nKWAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYWxsOiBBcGlDYWxsRm48Uj4gPSBhc3luYyA8TSBleHRlbmRzIE1ldGhvZHM8Uj4+KFxuICAgICAgICBtZXRob2Q6IE0sXG4gICAgICAgIHA6IFBheWxvYWQ8TSwgUj4sXG4gICAgICAgIHNpZ25hbD86IEFib3J0U2lnbmFsLFxuICAgICkgPT4ge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gcCA/PyB7fTtcbiAgICAgICAgZGVidWcoYENhbGxpbmcgJHttZXRob2R9YCk7XG4gICAgICAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkgdmFsaWRhdGVTaWduYWwobWV0aG9kLCBwYXlsb2FkLCBzaWduYWwpO1xuICAgICAgICAvLyBHZW5lcmFsIGNvbmZpZ1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBmb3JtRGF0YVJlcXVpcmVkID0gcmVxdWlyZXNGb3JtRGF0YVVwbG9hZChwYXlsb2FkKTtcbiAgICAgICAgLy8gU2hvcnQtY2lyY3VpdCBvbiB3ZWJob29rIHJlcGx5XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMud2ViaG9va1JlcGx5RW52ZWxvcGUuc2VuZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhdGhpcy5oYXNVc2VkV2ViaG9va1JlcGx5ICYmXG4gICAgICAgICAgICAhZm9ybURhdGFSZXF1aXJlZCAmJlxuICAgICAgICAgICAgb3B0cy5jYW5Vc2VXZWJob29rUmVwbHkobWV0aG9kKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuaGFzVXNlZFdlYmhvb2tSZXBseSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBjcmVhdGVKc29uUGF5bG9hZCh7IC4uLnBheWxvYWQsIG1ldGhvZCB9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud2ViaG9va1JlcGx5RW52ZWxvcGUuc2VuZChjb25maWcuYm9keSk7XG4gICAgICAgICAgICByZXR1cm4geyBvazogdHJ1ZSwgcmVzdWx0OiB0cnVlIGFzIEFwaUNhbGxSZXN1bHQ8TSwgUj4gfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdGltZW91dHMgYW5kIGVycm9ycyBpbiB0aGUgdW5kZXJseWluZyBmb3JtLWRhdGEgc3RyZWFtXG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXJGcm9tU2lnbmFsKHNpZ25hbCk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0KGNvbnRyb2xsZXIsIG9wdHMudGltZW91dFNlY29uZHMsIG1ldGhvZCk7XG4gICAgICAgIGNvbnN0IHN0cmVhbUVyciA9IGNyZWF0ZVN0cmVhbUVycm9yKGNvbnRyb2xsZXIpO1xuICAgICAgICAvLyBCdWlsZCByZXF1ZXN0IFVSTCBhbmQgY29uZmlnXG4gICAgICAgIGNvbnN0IHVybCA9IG9wdHMuYnVpbGRVcmwoXG4gICAgICAgICAgICBvcHRzLmFwaVJvb3QsXG4gICAgICAgICAgICB0aGlzLnRva2VuLFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgb3B0cy5lbnZpcm9ubWVudCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZm9ybURhdGFSZXF1aXJlZFxuICAgICAgICAgICAgPyBjcmVhdGVGb3JtRGF0YVBheWxvYWQocGF5bG9hZCwgKGVycikgPT4gc3RyZWFtRXJyLmNhdGNoKGVycikpXG4gICAgICAgICAgICA6IGNyZWF0ZUpzb25QYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICBjb25zdCBzaWcgPSBjb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgLi4ub3B0cy5iYXNlRmV0Y2hDb25maWcsIHNpZ25hbDogc2lnLCAuLi5jb25maWcgfTtcbiAgICAgICAgLy8gUGVyZm9ybSBmZXRjaCBjYWxsLCBhbmQgaGFuZGxlIG5ldHdvcmtpbmcgZXJyb3JzXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NQcm9taXNlID0gZmV0Y2goXG4gICAgICAgICAgICB1cmwgaW5zdGFuY2VvZiBVUkwgPyB1cmwuaHJlZiA6IHVybCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICkuY2F0Y2godG9IdHRwRXJyb3IobWV0aG9kLCBvcHRzLnNlbnNpdGl2ZUxvZ3MpKTtcbiAgICAgICAgLy8gVGhvc2UgYXJlIHRoZSB0aHJlZSBwb3NzaWJsZSBvdXRjb21lcyBvZiB0aGUgZmV0Y2ggY2FsbDpcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtzdWNjZXNzUHJvbWlzZSwgc3RyZWFtRXJyLnByb21pc2UsIHRpbWVvdXQucHJvbWlzZV07XG4gICAgICAgIC8vIFdhaXQgZm9yIHJlc3VsdFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgUHJvbWlzZS5yYWNlKG9wZXJhdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAodGltZW91dC5oYW5kbGUgIT09IHVuZGVmaW5lZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQuaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB1c2UoLi4udHJhbnNmb3JtZXJzOiBUcmFuc2Zvcm1lcjxSPltdKSB7XG4gICAgICAgIHRoaXMuY2FsbCA9IHRyYW5zZm9ybWVycy5yZWR1Y2UoY29uY2F0VHJhbnNmb3JtZXIsIHRoaXMuY2FsbCk7XG4gICAgICAgIHRoaXMuaW5zdGFsbGVkVHJhbnNmb3JtZXJzLnB1c2goLi4udHJhbnNmb3JtZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FsbEFwaTxNIGV4dGVuZHMgTWV0aG9kczxSPj4oXG4gICAgICAgIG1ldGhvZDogTSxcbiAgICAgICAgcGF5bG9hZDogUGF5bG9hZDxNLCBSPixcbiAgICAgICAgc2lnbmFsPzogQWJvcnRTaWduYWwsXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNhbGwobWV0aG9kLCBwYXlsb2FkLCBzaWduYWwpO1xuICAgICAgICBpZiAoZGF0YS5vaykgcmV0dXJuIGRhdGEucmVzdWx0O1xuICAgICAgICBlbHNlIHRocm93IHRvR3JhbW15RXJyb3IoZGF0YSwgbWV0aG9kLCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0cmFuc2Zvcm1hYmxlIEFQSSwgaS5lLiBhbiBvYmplY3QgdGhhdCBsZXRzIHlvdSBwZXJmb3JtIHJhdyBBUElcbiAqIGNhbGxzIHRvIHRoZSBUZWxlZ3JhbSBCb3QgQVBJIHNlcnZlciBidXQgcGFzcyB0aGUgY2FsbHMgdGhyb3VnaCBhIHN0YWNrIG9mXG4gKiB0cmFuc2Zvcm1lcnMgYmVmb3JlLiBUaGlzIHdpbGwgY3JlYXRlIGEgbmV3IEFQSSBjbGllbnQgaW5zdGFuY2UgdW5kZXIgdGhlXG4gKiBob29kIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbm5lY3QgdG8gdGhlIFRlbGVncmFtIHNlcnZlcnMuIFlvdSB0aGVyZWZvcmUgbmVlZFxuICogdG8gcGFzcyB0aGUgYm90IHRva2VuLiBJbiBhZGRpdGlvbiwgeW91IG1heSBwYXNzIEFQSSBjbGllbnQgb3B0aW9ucyBhcyB3ZWxsXG4gKiBhcyBhIHdlYmhvb2sgcmVwbHkgZW52ZWxvcGUgdGhhdCBhbGxvd3MgdGhlIGNsaWVudCB0byBwZXJmb3JtIHVwIHRvIG9uZSBIVFRQXG4gKiByZXF1ZXN0IGluIHJlc3BvbnNlIHRvIGEgd2ViaG9vayBjYWxsIGlmIHRoaXMgaXMgZGVzaXJlZC5cbiAqXG4gKiBAcGFyYW0gdG9rZW4gVGhlIGJvdCdzIHRva2VuXG4gKiBAcGFyYW0gb3B0aW9ucyBBIG51bWJlciBvZiBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIGNyZWF0ZWQgQVBJIGNsaWVudFxuICogQHBhcmFtIHdlYmhvb2tSZXBseUVudmVsb3BlIFRoZSB3ZWJob29rIHJlcGx5IGVudmVsb3BlIHRoYXQgd2lsbCBiZSB1c2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSYXdBcGk8UiBleHRlbmRzIFJhd0FwaT4oXG4gICAgdG9rZW46IHN0cmluZyxcbiAgICBvcHRpb25zPzogQXBpQ2xpZW50T3B0aW9ucyxcbiAgICB3ZWJob29rUmVwbHlFbnZlbG9wZT86IFdlYmhvb2tSZXBseUVudmVsb3BlLFxuKTogVHJhbnNmb3JtYWJsZUFwaTxSPiB7XG4gICAgY29uc3QgY2xpZW50ID0gbmV3IEFwaUNsaWVudDxSPih0b2tlbiwgb3B0aW9ucywgd2ViaG9va1JlcGx5RW52ZWxvcGUpO1xuXG4gICAgY29uc3QgcHJveHlIYW5kbGVyOiBQcm94eUhhbmRsZXI8Uj4gPSB7XG4gICAgICAgIGdldChfLCBtOiBNZXRob2RzPFI+IHwgXCJ0b0pTT05cIikge1xuICAgICAgICAgICAgcmV0dXJuIG0gPT09IFwidG9KU09OXCJcbiAgICAgICAgICAgICAgICA/IFwiX19pbnRlcm5hbFwiXG4gICAgICAgICAgICAgICAgOiBjbGllbnQuY2FsbEFwaS5iaW5kKGNsaWVudCwgbSk7XG4gICAgICAgIH0sXG4gICAgICAgIC4uLnByb3h5TWV0aG9kcyxcbiAgICB9O1xuICAgIGNvbnN0IHJhdyA9IG5ldyBQcm94eSh7fSBhcyBSLCBwcm94eUhhbmRsZXIpO1xuICAgIGNvbnN0IGluc3RhbGxlZFRyYW5zZm9ybWVycyA9IGNsaWVudC5pbnN0YWxsZWRUcmFuc2Zvcm1lcnM7XG4gICAgY29uc3QgYXBpOiBUcmFuc2Zvcm1hYmxlQXBpPFI+ID0ge1xuICAgICAgICByYXcsXG4gICAgICAgIGluc3RhbGxlZFRyYW5zZm9ybWVycyxcbiAgICAgICAgdXNlOiAoLi4udCkgPT4ge1xuICAgICAgICAgICAgY2xpZW50LnVzZSguLi50KTtcbiAgICAgICAgICAgIHJldHVybiBhcGk7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHJldHVybiBhcGk7XG59XG5cbmNvbnN0IGRlZmF1bHRCdWlsZFVybDogTm9uTnVsbGFibGU8QXBpQ2xpZW50T3B0aW9uc1tcImJ1aWxkVXJsXCJdPiA9IChcbiAgICByb290LFxuICAgIHRva2VuLFxuICAgIG1ldGhvZCxcbiAgICBlbnYsXG4pID0+IHtcbiAgICBjb25zdCBwcmVmaXggPSBlbnYgPT09IFwidGVzdFwiID8gXCJ0ZXN0L1wiIDogXCJcIjtcbiAgICByZXR1cm4gYCR7cm9vdH0vYm90JHt0b2tlbn0vJHtwcmVmaXh9JHttZXRob2R9YDtcbn07XG5cbmNvbnN0IHByb3h5TWV0aG9kcyA9IHtcbiAgICBzZXQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGRlZmluZVByb3BlcnR5KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgb3duS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG59O1xuXG4vKiogQSBjb250YWluZXIgZm9yIGEgcmVqZWN0aW5nIHByb21pc2UgKi9cbmludGVyZmFjZSBBc3luY0Vycm9yIHtcbiAgICBwcm9taXNlOiBQcm9taXNlPG5ldmVyPjtcbn1cbi8qKiBBbiBhc3luYyBlcnJvciBjYXVzZWQgYnkgYSB0aW1lb3V0ICovXG5pbnRlcmZhY2UgVGltZW91dCBleHRlbmRzIEFzeW5jRXJyb3Ige1xuICAgIGhhbmRsZTogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4gfCB1bmRlZmluZWQ7XG59XG4vKiogQW4gYXN5bmMgZXJyb3IgY2F1c2VkIGJ5IGFuIGVycm9yIGluIGFuIHVuZGVybHlpbmcgcmVzb3VyY2Ugc3RyZWFtICovXG5pbnRlcmZhY2UgU3RyZWFtRXJyb3IgZXh0ZW5kcyBBc3luY0Vycm9yIHtcbiAgICBjYXRjaDogKGVycjogdW5rbm93bikgPT4gdm9pZDtcbn1cblxuLyoqIENyZWF0ZXMgYSB0aW1lb3V0IGVycm9yIHdoaWNoIGFib3J0cyBhIGdpdmVuIGNvbnRyb2xsZXIgKi9cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVvdXQoXG4gICAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyLFxuICAgIHNlY29uZHM6IG51bWJlcixcbiAgICBtZXRob2Q6IHN0cmluZyxcbik6IFRpbWVvdXQge1xuICAgIGxldCBoYW5kbGU6IFRpbWVvdXRbXCJoYW5kbGVcIl0gPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPG5ldmVyPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbXNnID1cbiAgICAgICAgICAgICAgICBgUmVxdWVzdCB0byAnJHttZXRob2R9JyB0aW1lZCBvdXQgYWZ0ZXIgJHtzZWNvbmRzfSBzZWNvbmRzYDtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IobXNnKSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH0sIDEwMDAgKiBzZWNvbmRzKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBwcm9taXNlLCBoYW5kbGUgfTtcbn1cbi8qKiBDcmVhdGVzIGEgc3RyZWFtIGVycm9yIHdoaWNoIGFib3J0IGEgZ2l2ZW4gY29udHJvbGxlciAqL1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtRXJyb3IoYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpOiBTdHJlYW1FcnJvciB7XG4gICAgbGV0IG9uRXJyb3I6IFN0cmVhbUVycm9yW1wiY2F0Y2hcIl0gPSAoZXJyKSA9PiB7XG4gICAgICAgIC8vIFJlLXRocm93IGJ5IGRlZmF1bHQsIGJ1dCB3aWxsIGJlIG92ZXJ3cml0dGVuIGltbWVkaWF0ZWx5XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxuZXZlcj4oKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICBvbkVycm9yID0gKGVycjogdW5rbm93bikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBwcm9taXNlLCBjYXRjaDogb25FcnJvciB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBYm9ydENvbnRyb2xsZXJGcm9tU2lnbmFsKHNpZ25hbD86IEFib3J0U2lnbmFsKSB7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGlmIChzaWduYWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGFib3J0Q29udHJvbGxlcjtcbiAgICBjb25zdCBzaWcgPSBzaWduYWw7XG4gICAgZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICBzaWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0KTtcbiAgICB9XG4gICAgaWYgKHNpZy5hYm9ydGVkKSBhYm9ydCgpO1xuICAgIGVsc2Ugc2lnLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydCk7XG4gICAgcmV0dXJuIHsgYWJvcnQsIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ25hbChcbiAgICBtZXRob2Q6IHN0cmluZyxcbiAgICBwYXlsb2FkOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICBzaWduYWw6IEFib3J0U2lnbmFsLFxuKSB7XG4gICAgLy8gV2UgdXNlIGEgdmVyeSBzaW1wbGUgaGV1cmlzdGljIHRvIGNoZWNrIGZvciBBYm9ydFNpZ25hbCBpbnN0YW5jZXNcbiAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBkb2luZyBhIHJ1bnRpbWUtc3BlY2lmaWMgdmVyc2lvbiBvZiBgaW5zdGFuY2VvZmAuXG4gICAgaWYgKHR5cGVvZiBzaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHBheWxvYWQwID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgaWYgKHBheWxvYWQwLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgIHBheWxvYWQwID0gcGF5bG9hZDAuc3Vic3RyaW5nKDAsIDE2KSArIFwiIC4uLlwiO1xuICAgIH1cbiAgICBsZXQgcGF5bG9hZDEgPSBKU09OLnN0cmluZ2lmeShzaWduYWwpO1xuICAgIGlmIChwYXlsb2FkMS5sZW5ndGggPiAyMCkge1xuICAgICAgICBwYXlsb2FkMSA9IHBheWxvYWQxLnN1YnN0cmluZygwLCAxNikgKyBcIiAuLi5cIjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW5jb3JyZWN0IGFib3J0IHNpZ25hbCBpbnN0YW5jZSBmb3VuZCEgXFxcbllvdSBwYXNzZWQgdHdvIHBheWxvYWRzIHRvICcke21ldGhvZH0nIGJ1dCB5b3Ugc2hvdWxkIG1lcmdlIFxcXG50aGUgc2Vjb25kIG9uZSBjb250YWluaW5nICcke3BheWxvYWQxfScgaW50byB0aGUgZmlyc3Qgb25lIFxcXG5jb250YWluaW5nICcke3BheWxvYWQwfSchIElmIHlvdSBhcmUgdXNpbmcgY29udGV4dCBzaG9ydGN1dHMsIFxcXG55b3UgbWF5IHdhbnQgdG8gdXNlIGEgbWV0aG9kIG9uICdjdHguYXBpJyBpbnN0ZWFkLlxuXG5JZiB5b3Ugd2FudCB0byBwcmV2ZW50IHN1Y2ggbWlzdGFrZXMgaW4gdGhlIGZ1dHVyZSwgXFxcbmNvbnNpZGVyIHVzaW5nIFR5cGVTY3JpcHQuIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9gLFxuICAgICk7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxlQUFlLEVBQUUsU0FBUyxDQUFDLFFBQVEsc0JBQXNCO0FBTWxFLFNBQVMsYUFBYSxFQUFFLFdBQVcsUUFBUSxhQUFhO0FB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